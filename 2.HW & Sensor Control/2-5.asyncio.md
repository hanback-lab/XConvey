# 비동기 제어 
운영체제는 스케쥴링을 통해 여러 프로그램을 동시에 실행할 수 있습니다. 초기 스케줄링의 기본 단위는 프로그램의 상태를 관리하는 프로세스였습니다. 



```python
import threading, time 
is_stoped = False

def work_thread(symbol):
    global is_stoped
    while not is_stoped:
        print(symbol, end='', flush=True)
        time.sleep(20/1000)

work = threading.Thread(target=work_thread, args=('o',), daemon=True)
work.start()

try:
    while True:
        print('x', end='', flush=True)
        time.sleep(20/1000)
except KeyboardInterrupt:
    is_stoped = True
    work.join()  
```
```out
oxoxxoxoxoxoxoxoxoxoxoxooxoxoxxooxxoxoxoxoxoxoxoxooxoxoxoxoxoxxoxoxo^C
```

다음과 같이 메인스레드 이외에 두개 또는 여러 개의 스레드를 생성하여 동작하는것도 가능합니다.

```python
import threading, time

def thread_a(n):
    for i in range(1,n+1):
        print("thread a :", i)
        time.sleep(0.5)

def thread_b(n):
    for i in range(1, n+5):   
        print("thread b :", i)
        time.sleep(0.7)

t1 = threading.Thread(target=thread_a, args=(5,))
t1.start()
t2 = threading.Thread(target=thread_b, args=(5,)) 
t2.start()

for i in range(3, 0, -1):
    print("main :", i)
    time.sleep(1)

t1.join()
t2.join()
```

```out
thread a : 1
thread b : 1
main : 3
thread a : 2
thread b : 2
main : 2
thread a : 3
thread b : 3
thread a : 4
main : 1
thread a : 5
thread b : 4
thread b : 5
thread b : 6
thread b : 7
thread b : 8
thread b : 9
```

동작 결과를 확인해보면 메인 스레드와 thread_a 와 thread_b가 각각 동시에 작업을 수행하며 지정된 문자를 출력하는 것을 볼 수 있습니다. 이 상태에서 전역 변수로 생성되어 있는 변수에 각스레드에서 모두 접근하게 된다면 스레드가 접근하는 순서에 따라서 변수의 값이 원하지 않는 상태로 변하는 경우도 발생할 수 있습니다. 

이러한 상태를 경쟁 상태라고 합니다. 이를 해결하기 위해서는 Lock 객체를 활용하여 스레드에서 같은 자원에 접근하는 순간에 먼저 접근한 스레드에서 자원을 활용하고 반환하고나서 다시 활용하도록 동기화하여 프로그래밍을 진행합니다. 

```python
from threading import Thread, Lock
import time

lock = Lock()
number = 0

def thread_a():
    global number
    lock.acquire()
    for i in range(1,5):
        number += i 
        print("thread a :", number)
        time.sleep(0.5)
    lock.release()

def thread_b():
    global number
    lock.acquire()
    for i in range(1,5):
        number -= i 
        print("thread b :", number)
        time.sleep(0.5)
    lock.release()

t1 = Thread(target=thread_a)
t2 = Thread(target=thread_b)

t1.start()
time.sleep(2)
t2.start()

t1.join()
t2.join()
```

```out
thread a : 1
thread a : 3
thread a : 6
thread a : 10
thread b : 9
thread b : 7
thread b : 4
thread b : 0
```

## 스레드를 활용한 커튼 제어 및 피드백 확인 
액츄에이터의 피드백 데이터는 명령을 실행하고 나서 실제 동작이 이루어진 후 다시 반환 되는 형태로, 최대한 빠르게 구성한다고 하여도 제어와 동시에 피드백 데이터를 수신하는것은 불가능합니다. 따라서 제어 신호를 전달하는 구문과 현재 제어상태를 확인하는 구문을 분리하여 동작 시킨다면 제어 신호가 전달되고 피드백 데이터가 수신되는데까지 소요되는 시간도 확인이 가능하고, 상태값의 변화에 따라 제어 명령이 정상적으로 수행했는지 빠른시간에 확인이 가능합니다. 아래 코드는 커튼을 메인스레드에서 제어 명령을 송신하고 별도의 스레드에서 피드백 데이터를 확인하여 출력하는 내용입니다. 

```python
from xhome.actuator import Curtain
import time, threading 

curtain = Curtain()
thread_run = True

def print_state():
    global curtain, stop
    while thread_run:
        print(curtain.state)
        time.sleep(0.1)

cth = threading.Thread(target=print_state,daemon=True)
cth.start()

curtain.open()
time.sleep(2)
curtain.stop()
time.sleep(2)
curtain.open()
time.sleep(2)
curtain.close()
time.sleep(2)
curtain.stop()
time.sleep(2)
curtain.close()
time.sleep(2)

thread_run = False
cth.join()
```

```out
{'room': 'middle'}
{'room': 'middle'}
{'room': 'middle'}
...중략...
{'room': 'open'}
{'room': 'open'}
{'room': 'open'}
...중략...
{'room': 'middle'}
{'room': 'middle'}
{'room': 'middle'}
...중략...
{'room': 'close'}
{'room': 'close'}
{'room': 'close'}
```

## 연습 문제  
앞의 커튼 제어에 따른 피드백 데이터 출력을 활용하여 상태가 열림으로 변화하면 ...